# Akashi — example environment configuration
# ─────────────────────────────────────────────────────────────────────────────
# Copy this file to .env and fill in values for your environment.
# For docker compose local dev, most defaults work as-is.
# Production deployments must set every variable marked REQUIRED.
#
# Full reference: docs/configuration.md
# ─────────────────────────────────────────────────────────────────────────────


# ── Database ──────────────────────────────────────────────────────────────────

# REQUIRED. Connection string for queries and writes.
# docker compose default: postgres://akashi:akashi@localhost:5432/akashi?sslmode=disable
# The docker-compose.yml uses this value (or its own default) automatically —
# set it here to override with an external database (e.g. TimescaleDB Cloud).
DATABASE_URL=postgres://akashi:akashi@localhost:5432/akashi?sslmode=disable

# REQUIRED for real-time SSE push (conflicts, new decisions).
# Must be a direct Postgres connection — NOT through PgBouncer.
# Set to empty to disable SSE push entirely:
#   NOTIFY_URL=
NOTIFY_URL=postgres://akashi:akashi@localhost:5432/akashi?sslmode=disable

# Password used by the Postgres container and the connection strings above.
# Change this for any environment that is network-accessible.
POSTGRES_PASSWORD=akashi


# ── Authentication ────────────────────────────────────────────────────────────

# REQUIRED. Bootstrap API key for the built-in "admin" agent.
# On first start with an empty agents table, this key is written to the DB.
# Change this. "admin" is fine for local dev; use something secret elsewhere.
AKASHI_ADMIN_API_KEY=admin

# JWT signing keys — STRONGLY RECOMMENDED even for local dev.
#
# When these are empty, the server generates a fresh ephemeral Ed25519 key
# pair on every startup. That means every container rebuild or process restart
# invalidates all existing tokens and browser sessions — you have to log in
# again every time you restart.
#
# To generate persistent keys (run once from the repo root):
#   go run scripts/genkey/main.go
#
# This writes data/jwt_private.pem and data/jwt_public.pem, which are
# gitignored and automatically picked up by docker-compose.yml.
# Paths inside the container (docker compose mounts ./data as /data):
AKASHI_JWT_PRIVATE_KEY=/data/jwt_private.pem
AKASHI_JWT_PUBLIC_KEY=/data/jwt_public.pem

# How long issued tokens are valid. Extend for less friction in local dev;
# shorten for production.
# AKASHI_JWT_EXPIRATION=24h


# ── Server ────────────────────────────────────────────────────────────────────

AKASHI_PORT=8080

# debug, info, warn, error
AKASHI_LOG_LEVEL=info

# Comma-separated origins allowed for browser cross-origin requests.
# Empty = deny all cross-origin requests (fine for local dev, fix for prod).
# AKASHI_CORS_ALLOWED_ORIGINS=https://your-domain.com


# ── Embeddings ────────────────────────────────────────────────────────────────
#
# Embeddings power semantic search and conflict detection. Without a working
# embedding provider those features fall back to text search / are disabled.
#
# Provider selection:
#   auto   — try Ollama first, then OpenAI if OPENAI_API_KEY is set, else noop
#   ollama — use Ollama (local, free)
#   openai — use OpenAI (requires OPENAI_API_KEY)
#   noop   — disable embeddings entirely

AKASHI_EMBEDDING_PROVIDER=auto

# OpenAI (recommended for cloud/production)
# Set this and the server auto-detects OpenAI in "auto" mode.
OPENAI_API_KEY=
AKASHI_EMBEDDING_MODEL=text-embedding-3-small

# Ollama (optional, local on-premises — not included in docker-compose)
# Run Ollama separately and point here to use it for embeddings.
OLLAMA_URL=http://localhost:11434
OLLAMA_MODEL=mxbai-embed-large

# Vector dimensionality — must match the chosen model.
# mxbai-embed-large = 1024, text-embedding-3-small = 1536 (truncated to 1024)
AKASHI_EMBEDDING_DIMENSIONS=1024


# ── Vector Search (Qdrant) ────────────────────────────────────────────────────
#
# Qdrant is optional. When not configured, search falls back to PostgreSQL
# full-text search. The docker-compose.yml runs Qdrant in-stack for local dev
# and wires QDRANT_URL automatically.
#
# Override to point at Qdrant Cloud or a remote instance:
# QDRANT_URL=https://xyz.cloud.qdrant.io:6333
# QDRANT_API_KEY=
# QDRANT_COLLECTION=akashi_decisions


# ── Conflict Detection ────────────────────────────────────────────────────────
#
# Conflicts are detected automatically after every trace. An optional LLM
# validation step filters false positives before they're stored.
#
# Leave empty to auto-detect: uses OpenAI (gpt-4o-mini) if OPENAI_API_KEY is set,
# otherwise no LLM validation (more false positives, no extra latency).
# Set to an Ollama model name to use local LLM validation instead:
# AKASHI_CONFLICT_LLM_MODEL=qwen2.5:3b
AKASHI_CONFLICT_LLM_MODEL=


# ── Write-Ahead Log ───────────────────────────────────────────────────────────
#
# The WAL ensures in-memory events survive a crash between flush intervals.
# Enabled by default. The docker compose stack mounts ./data as /data in the
# container, so WAL files survive container restarts.

# AKASHI_WAL_DIR=./data/wal      # default; override to place WAL on faster disk
# AKASHI_WAL_DISABLE=false       # set true only for dev/testing (data loss on crash)
# AKASHI_WAL_SYNC_MODE=batch     # full | batch | none


# ── Observability (OpenTelemetry) ─────────────────────────────────────────────
#
# Leave empty to disable OTEL entirely.
# OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4318
# OTEL_EXPORTER_OTLP_INSECURE=true
# OTEL_SERVICE_NAME=akashi


# ── Idempotency ───────────────────────────────────────────────────────────────
#
# Retention for idempotency records (used for retry-safe writes).
AKASHI_IDEMPOTENCY_CLEANUP_INTERVAL=1h
AKASHI_IDEMPOTENCY_COMPLETED_TTL=168h
AKASHI_IDEMPOTENCY_ABANDONED_TTL=24h


# ── Safety Gates ─────────────────────────────────────────────────────────────
#
# Destructive delete is disabled by default. Enable only for controlled GDPR
# workflows — the endpoint permanently deletes an agent and all their data.
AKASHI_ENABLE_DESTRUCTIVE_DELETE=false
