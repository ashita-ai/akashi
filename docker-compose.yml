# Akashi: Binary-only mode.
#
# Just the Akashi server. Bring your own TimescaleDB, Qdrant, and embedding provider.
# Configure everything via environment variables or a .env file.
#
# Usage:
#   cp docker/env.example .env
#   # Edit .env with your DATABASE_URL, QDRANT_URL, and API keys
#   docker compose up -d --build
#
# For a zero-config local stack (TimescaleDB + Qdrant + Ollama all included), use:
#   docker compose -f docker-compose.complete.yml up -d

services:
  akashi:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: akashi-server
    restart: unless-stopped
    ports:
      - "127.0.0.1:8080:8080"
    env_file:
      - path: .env
        required: false
    environment:
      # Required: set these in .env or pass directly.
      DATABASE_URL: ${DATABASE_URL:?DATABASE_URL is required — set it in .env}
      NOTIFY_URL: ${NOTIFY_URL:-${DATABASE_URL:?}}
      AKASHI_ADMIN_API_KEY: ${AKASHI_ADMIN_API_KEY:?AKASHI_ADMIN_API_KEY is required}

      # Optional — Qdrant for vector search. Without it, search falls back to text.
      QDRANT_URL: ${QDRANT_URL:-}
      QDRANT_API_KEY: ${QDRANT_API_KEY:-}
      QDRANT_COLLECTION: ${QDRANT_COLLECTION:-akashi_decisions}

      # Optional — embeddings. Without a provider, semantic search and conflict
      # detection are disabled (text search still works).
      AKASHI_EMBEDDING_PROVIDER: ${AKASHI_EMBEDDING_PROVIDER:-auto}
      AKASHI_EMBEDDING_DIMENSIONS: ${AKASHI_EMBEDDING_DIMENSIONS:-1024}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      AKASHI_EMBEDDING_MODEL: ${AKASHI_EMBEDDING_MODEL:-text-embedding-3-small}
      OLLAMA_URL: ${OLLAMA_URL:-}
      OLLAMA_MODEL: ${OLLAMA_MODEL:-mxbai-embed-large}

      # Optional — LLM conflict validation (reduces false positives ~93%).
      AKASHI_CONFLICT_LLM_MODEL: ${AKASHI_CONFLICT_LLM_MODEL:-}

      AKASHI_PORT: ${AKASHI_PORT:-8080}
      AKASHI_LOG_LEVEL: ${AKASHI_LOG_LEVEL:-info}

      # JWT signing keys. Without these, ephemeral keys are generated each restart,
      # invalidating all existing tokens. For persistent sessions, generate keys:
      #   openssl genpkey -algorithm ed25519 -out data/jwt_private.pem
      #   openssl pkey -in data/jwt_private.pem -pubout -out data/jwt_public.pem
      # Then mount ./data:/data and set these paths.
      AKASHI_JWT_PRIVATE_KEY: ${AKASHI_JWT_PRIVATE_KEY:-}
      AKASHI_JWT_PUBLIC_KEY: ${AKASHI_JWT_PUBLIC_KEY:-}
      AKASHI_JWT_EXPIRATION: ${AKASHI_JWT_EXPIRATION:-24h}

      OTEL_EXPORTER_OTLP_ENDPOINT: ${OTEL_EXPORTER_OTLP_ENDPOINT:-}
      OTEL_SERVICE_NAME: ${OTEL_SERVICE_NAME:-akashi}
    volumes:
      # Mount ./data if using persistent JWT keys.
      - ./data:/data
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:8080/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 15s
